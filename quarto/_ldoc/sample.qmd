# Initial sample

In general, we are interested in functions on a hypercube in
$[0,1]^d$, though we can deal with more general regions.  For many of
us, our first inclination is either random sampling or sampling on a
grid.  However, choosing independent random samples tends to lead to
"clumps" of points in some parts of the domain, and so is not terribly
efficient; and sampling on a grid tends to get expensive as $d$ grows.
Therefore, we usually default to either statistical experimental
design methods like Latin hypercubes, or we use a *low-discrepancy*
sequence, usually generated by something that looks like a low-quality
random number generator.

There is a [nice blog post][kronecker-lds-blog] on low discrepancy
sequences that gives some of the relevant background and recommends a
fairly effective sampler based on Kronecker sequences.  We provide
some Julia code for this below.

[kronecker-lds-blog]: https://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/


```{.julia}
"""
    kronecker_quasirand(d, N, start=0)

Return an `d`-by-`N` array of `N` quasi-random samples in [0, 1]^d
generated by an additive quasi-random low-discrepancy sample sequence.
"""
function kronecker_quasirand(d, N, start=0)

    # Compute the recommended constants ("generalized golden ratio")
    ϕ = 1.0+1.0/d
    for k = 1:10
        gϕ = ϕ^(d+1)-ϕ-1
        dgϕ= (d+1)*ϕ^d-1
        ϕ -= gϕ/dgϕ
    end
    αs = [mod(1.0/ϕ^j, 1.0) for j=1:d]

    # Compute the quasi-random sequence
    Z = zeros(d, N)
    for j = 1:N
        for i=1:d
            Z[i,j] = mod(0.5 + (start+j)*αs[i], 1.0)
        end
    end

    Z
end

```

A 2D plot shows the difference between using random samples and the
low-discrepancy sequence.

```{julia}
#| echo: false
let
    Zr = rand(2,100)
    Zk = kronecker_quasirand(2,100)
    p1 = scatter(Zr[1,:], Zr[2,:], legend=:false, title="Random")
    p2 = scatter(Zk[1,:], Zk[2,:], legend=:false, title="Kronecker")
    plot(p1, p2, layout = @layout [a b])
end
```

